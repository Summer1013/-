# 1 java面向对象的四大特性

封装、继承、多态、抽象。

# 2  什么是Java程序的主类？应用程序和小程序的主类有何不同？

一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含 main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子 类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是 Java程序执行的入口点。

# 3 Java语言有哪些特点

封装、继承、多态、抽象。

# 4 访问修饰符public,private,protected,以及默认时的区别？

|           | 同类 | 同包 | 子类 | 其他包 |
| --------- | ---- | ---- | ---- | ------ |
| public    | √    | √    | √    | √      |
| protected | √    | √    | √    | ×      |
| default   | √    | √    | ×    | ×      |
| private   | √    | ×    | ×    | ×      |

# 5 float f=3.4;是否正确？

不正确,3.4是小数默认是双精度数double,可能会有精度损失,我们可以写成3.4F

# 6 Java有没有goto？

goto 是Java中的保留字，在目前版本的Java中没有使用。（根据James Gosling（Java之 父）编写的《The Java Programming Language》一书的附录中给出了一个Java关键字列表，其中有goto和const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保 留字，其实保留字这个词应该有更广泛的意义，因为熟悉C语言的程序员都知道，在系统类库 中使用过的有特殊意义的单词或单词的组合都被视为保留字）

# 7 &和&&的区别？

&运算符有两种用法：(1)按位与；(2)逻辑与。

&&运算符是短路与运算。

逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个 表达式的值才是true。&&之所以称为短路与运算是因为，如果&&左边的表达式的值是false，右 边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在 验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &&!username.equals("")，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果 不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注 意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。

# 8 Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？

round函数的本质  加0.5再向下取整

# 9 什么是Java注释

定义：用于解释说明程序的文字

Java注释的分类

- 单行注释
- 多行注释
- 文档注释

Java注释的作用

在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。

注意事项：多行和文档注释都不能嵌套使用。

# 10 Java有哪些数据类型

定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。

- 八大基本数据类型
  - byte
  - char
  - short
  - int
  - long
  - float
  - double
  - boolean
- 引用数据类型
  - 类(class)
  - 接口(interface)
  - 数组([])
  - String
  - 枚举Enum

# 11 final 有什么用？

用于修饰类、属性和方法；

- 被final修饰的类不可以被继承
- 被final修饰的方法不可以被重写
- 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向 的内容，引用指向的内容是可以改变的

# 12 final finally finalize的区别

- final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能 被重写、修饰变量表 示该变量是一个常量不能被重新赋值。
- finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代 码方法finally代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
- finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一 般由垃圾回收器来调 用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一 个对象是否可回收的 最后判断。

# 13 String str = “i” 和String str = new String(“i”)一样吗？

不一样，因为内存的分配方式不一样。String str = "i"的方式JVM会将其分配到常量池中，而 String str = new String("i")JVM会将其分配到堆内存中。

# 14 Java 中操作字符串都有哪些类？它们之间有什么区别？

操作字符串的类有：String、StringBuffer、StringBuilder。

String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操 作都会生成新的 String 对象，再将指针指向新的 String 对象，而 StringBuffer 、 StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好 不要使用 String。

StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线 程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。

# 15 Java中为什么要用 clone？

在实际编程过程中，我们常常要遇到这种情况：有一个对象 A，在某一时刻 A 中已经包含了一 些有效值，此时可能会需要一个和 A 完全相同新对象 B，并且此后对 B 任何改动都不会影响到 A 中的值，也就是说，A 与 B 是两个独立的对象，但 B 的初始值是由 A 对象确定的。在 Java 语言中，用简单的赋值语句是不能满足这种需求的。要满足这种需求虽然有很多途径，但 clone()方法是其中最简单，也是最高效的手段。

# 16 深克隆和浅克隆？

浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向 原有属性所指向的对象的内存地址。

深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。

# 17 new一个对象的过程和clone一个对象的区别？

new 操作符的本意是分配内存。程序执行到 new 操作符时，首先去看 new 操作符后面的类 型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数， 填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把 他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。

clone 在第一步是和 new 相似的，都是分配内存，调用 clone 方法时，分配的内存和原对象 （即调用 clone 方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，填 充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发 布到外部。

# 18 Java中实现多态的机制是什么？

Java中的多态靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程 序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存 里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。

# 19 谈谈你对多态的理解？

多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源代码，就可以让引用变量绑定到各种不同的对象上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让**程序可以选择多个运行状态**，这就是多态性。

# 20 构造器（constructor）是否可被重写（override）？

构造器不能被继承，因此不能被重写，但可以被重载。

# 21 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对 不对？

不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。

Java对于eqauls方法和hashCode方法是这样规定的：

(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；

(2)如果两个对象的hashCode相同，它们并不一定相同。

当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如 果哈希码频繁的冲突将会造成存取性能急剧下降）。

# 22 == 和 equals 的区别是什么

- == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)

- equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况: 情况1:类没有覆盖 equals() 方法。则通过

  equals() 比较该类的两个对象时， 等价于通过“==”比较这两个对象。

# 23 是否可以继承String类？

String 类是final类，不可以被继承。

补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联关系 （Has-A）和依赖关系（Use-A）而不是继承关系（Is-A）。

# 24 String类的常用方法有哪些？

- indexof();返回指定字符的索引。
- charAt();返回指定索引处的字符。
- replace();字符串替换。
- trim();去除字符串两端空格。
- splt()；字符串分割，返回分割后的字符串数组。
- getBytes()；返回字符串byte类型数组。
- length()；返回字符串长度。
- toLowerCase();将字符串转换为小写字母。 •toUpperCase();将字符串转换为大写字母。
- substring();字符串截取。
- equals();比较字符串是否相等。

# 25 super关键字的用法

super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一 个父类。

super也有三种用法：

1.普通的直接引用

与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。

2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分

```java
class Person {
    protected String name;
    public Person(String name) {
        this.name = name;
    }
}
class Student extends Person {
    private String name;
    public Student(String name, String name1) {
        super(name);
        this.name = name1;
    }
    public void getInfo() {
        System.out.println(this.name);
        System.out.println(super.name);
    }
}
public class Test {
    public static void main(String[] args) {
        Student s1 = new Student("Father", "Child");
        s1.getInfo();
    }
}
```

3.引用父类构造函数

- super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。
- this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。

# 26 this与super的区别

- super:它引用当前对象的直接父类中的成员(用来访问直接父类中被隐藏的父类中成员)
- 数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名 （实参）
- this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）
- super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内
- 调用本类的其它构造方法。
- super()和this()均需放在构造方法内第一行。
- 尽管可以用this调用一个构造器，但却不能调用两个。
- this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数， 其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语 句，就失去了语句的意义，编译器也不会通过。
- this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。
- 从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。

# 27 



# 28 



# 29 



# 30 



# 31 



# 32 



# 33 



# 34 



# 35 



# 36 



# 37 



# 38 



# 39 



# 40 



# 41 



# 42 



# 43 



# 44 



# 45 



# 46 



# 47 